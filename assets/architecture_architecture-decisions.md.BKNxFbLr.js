import{_ as r,c as t,o as i,aE as o}from"./chunks/framework.CilPRo9n.js";const h=JSON.parse('{"title":"Architecture Decisions","description":"Architecture Decision Records (ADRs)","frontmatter":{"title":"Architecture Decisions","description":"Architecture Decision Records (ADRs)"},"headers":[],"relativePath":"architecture/architecture-decisions.md","filePath":"architecture/architecture-decisions.md"}'),n={name:"architecture/architecture-decisions.md"};function s(a,e,l,c,g,d){return i(),t("div",null,[...e[0]||(e[0]=[o('<h1 id="architecture-decisions" tabindex="-1">Architecture Decisions <a class="header-anchor" href="#architecture-decisions" aria-label="Permalink to “Architecture Decisions”">​</a></h1><p>This document records the architectural decisions made for the project, providing context on &quot;why&quot; certain technologies or patterns were chosen.</p><h2 id="adr-001-runtime-environment" tabindex="-1">ADR-001: Runtime Environment <a class="header-anchor" href="#adr-001-runtime-environment" aria-label="Permalink to “ADR-001: Runtime Environment”">​</a></h2><ul><li><strong>Status</strong>: Accepted</li><li><strong>Decision</strong>: Use <strong>Bun</strong> instead of Node.js.</li><li><strong>Context</strong>: We needed a high-performance runtime that simplifies the toolchain.</li><li><strong>Consequences</strong>: <ul><li>✅ <strong>Pros</strong>: Faster startup, built-in test runner, built-in package manager (no need for npm/yarn), TypeScript support out of the box.</li><li>⚠️ <strong>Cons</strong>: Some Node.js APIs might have partial compatibility (though improving daily).</li></ul></li></ul><h2 id="adr-002-orm-object-relational-mapping" tabindex="-1">ADR-002: ORM (Object-Relational Mapping) <a class="header-anchor" href="#adr-002-orm-object-relational-mapping" aria-label="Permalink to “ADR-002: ORM (Object-Relational Mapping)”">​</a></h2><ul><li><strong>Status</strong>: Accepted</li><li><strong>Decision</strong>: Use <strong>Drizzle ORM</strong>.</li><li><strong>Context</strong>: Validation of TypeORM (legacy/heavy) vs Prisma (slow cold start) vs Drizzle.</li><li><strong>Consequences</strong>: <ul><li>✅ <strong>Pros</strong>: Lightweight, &quot;If you know SQL, you know Drizzle&quot;, excellent type safety, no runtime overhead.</li><li>⚠️ <strong>Cons</strong>: Manual migration management is slightly more verbose than Prisma&#39;s auto-migrate-dev.</li></ul></li></ul><h2 id="adr-003-web-framework" tabindex="-1">ADR-003: Web Framework <a class="header-anchor" href="#adr-003-web-framework" aria-label="Permalink to “ADR-003: Web Framework”">​</a></h2><ul><li><strong>Status</strong>: Accepted</li><li><strong>Decision</strong>: Use <strong>Fastify</strong>.</li><li><strong>Context</strong>: Express is unmaintained/slow. NestJS is too opinionated/heavy for this micro-service goal.</li><li><strong>Consequences</strong>: <ul><li>✅ <strong>Pros</strong>: Highest performance in Node ecosystem, schema-based validation fits perfectly with Zod, great plugin ecosystem.</li><li>⚠️ <strong>Cons</strong>: Learning curve for hooks/plugins if coming from Express.</li></ul></li></ul><h2 id="adr-005-granular-error-handling" tabindex="-1">ADR-005: Granular Error Handling <a class="header-anchor" href="#adr-005-granular-error-handling" aria-label="Permalink to “ADR-005: Granular Error Handling”">​</a></h2><ul><li><strong>Status</strong>: Accepted</li><li><strong>Decision</strong>: Implement specific HTTP status codes (e.g., <strong>409 Conflict</strong>) instead of generic ones for resource state conflicts.</li><li><strong>Context</strong>: Relying on generic errors like 422 for everything makes it harder for API clients to handle specific business logic exceptions properly.</li><li><strong>Consequences</strong>: <ul><li>✅ <strong>Pros</strong>: Better client-side error handling, clearer API documentation, follows REST best practices.</li><li>⚠️ <strong>Cons</strong>: Slightly more verbose action logic to handle specific conflict scenarios.</li></ul></li></ul>',10)])])}const m=r(n,[["render",s]]);export{h as __pageData,m as default};

import{_ as e,c as r,o as n,aF as i}from"./chunks/framework.CBV2JRz2.js";const u=JSON.parse('{"title":"Architecture Decisions","description":"Architecture Decision Records (ADRs)","frontmatter":{"title":"Architecture Decisions","description":"Architecture Decision Records (ADRs)"},"headers":[],"relativePath":"architecture/architecture-decisions.md","filePath":"architecture/architecture-decisions.md"}'),a={name:"architecture/architecture-decisions.md"};function o(s,t,l,c,d,g){return n(),r("div",null,[...t[0]||(t[0]=[i('<h1 id="architecture-decisions" tabindex="-1">Architecture Decisions <a class="header-anchor" href="#architecture-decisions" aria-label="Permalink to “Architecture Decisions”">​</a></h1><p>This document records the architectural decisions made for the project, providing context on &quot;why&quot; certain technologies or patterns were chosen.</p><h2 id="adr-001-runtime-environment" tabindex="-1">ADR-001: Runtime Environment <a class="header-anchor" href="#adr-001-runtime-environment" aria-label="Permalink to “ADR-001: Runtime Environment”">​</a></h2><ul><li><strong>Status</strong>: Accepted</li><li><strong>Decision</strong>: Use <strong>Bun</strong> instead of Node.js.</li><li><strong>Context</strong>: We needed a high-performance runtime that simplifies the toolchain and offers native TypeScript execution without complex configuration.</li></ul><h3 id="runtime-comparison" tabindex="-1">Runtime Comparison <a class="header-anchor" href="#runtime-comparison" aria-label="Permalink to “Runtime Comparison”">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:center;">Feature</th><th style="text-align:center;">Bun</th><th style="text-align:center;">Node.js</th></tr></thead><tbody><tr><td style="text-align:center;"><strong>Engine</strong></td><td style="text-align:center;">JavaScriptCore (Zig)</td><td style="text-align:center;">V8 (C++)</td></tr><tr><td style="text-align:center;"><strong>Startup</strong></td><td style="text-align:center;">&lt; 10ms</td><td style="text-align:center;">~50-100ms</td></tr><tr><td style="text-align:center;"><strong>Tooling</strong></td><td style="text-align:center;">Built-in (Test, Package, Build)</td><td style="text-align:center;">External (fragmented)</td></tr><tr><td style="text-align:center;"><strong>TS Support</strong></td><td style="text-align:center;">Native</td><td style="text-align:center;">via transpilier</td></tr></tbody></table><ul><li><strong>Consequences</strong>: <ul><li>✅ <strong>Pros</strong>: Faster startup, built-in test runner, built-in package manager (no need for npm/yarn), TypeScript support out of the box.</li><li>⚠️ <strong>Cons</strong>: Some Node.js APIs might have partial compatibility (though improving daily).</li></ul></li></ul><h2 id="adr-002-orm-object-relational-mapping" tabindex="-1">ADR-002: ORM (Object-Relational Mapping) <a class="header-anchor" href="#adr-002-orm-object-relational-mapping" aria-label="Permalink to “ADR-002: ORM (Object-Relational Mapping)”">​</a></h2><ul><li><strong>Status</strong>: Accepted</li><li><strong>Decision</strong>: Use <strong>Drizzle ORM</strong>.</li><li><strong>Context</strong>: Validation of TypeORM (legacy/heavy) vs Prisma (slow cold start) vs Drizzle. We prioritized performance and low abstraction overhead.</li></ul><h3 id="orm-comparison" tabindex="-1">ORM Comparison <a class="header-anchor" href="#orm-comparison" aria-label="Permalink to “ORM Comparison”">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">Feature</th><th style="text-align:center;">Drizzle</th><th style="text-align:center;">Prisma</th><th style="text-align:center;">TypeORM</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Runtime Overhead</strong></td><td style="text-align:center;">Zero</td><td style="text-align:center;">High (Rust Engine)</td><td style="text-align:center;">Medium</td></tr><tr><td style="text-align:left;"><strong>Cold Start</strong></td><td style="text-align:center;">Instant</td><td style="text-align:center;">200ms+</td><td style="text-align:center;">50ms+</td></tr><tr><td style="text-align:left;"><strong>abstraction</strong></td><td style="text-align:center;">Low (SQL-like)</td><td style="text-align:center;">High (DSL)</td><td style="text-align:center;">High (OOP)</td></tr><tr><td style="text-align:left;"><strong>Type Safety</strong></td><td style="text-align:center;">Native TS</td><td style="text-align:center;">Codegen</td><td style="text-align:center;">Decorators</td></tr></tbody></table><ul><li><strong>Consequences</strong>: <ul><li>✅ <strong>Pros</strong>: Lightweight, &quot;If you know SQL, you know Drizzle&quot;, excellent type safety, no runtime overhead.</li><li>⚠️ <strong>Cons</strong>: Manual migration management is slightly more verbose than Prisma&#39;s auto-migrate-dev.</li></ul></li></ul><h2 id="adr-003-web-framework" tabindex="-1">ADR-003: Web Framework <a class="header-anchor" href="#adr-003-web-framework" aria-label="Permalink to “ADR-003: Web Framework”">​</a></h2><ul><li><strong>Status</strong>: Accepted</li><li><strong>Decision</strong>: Use <strong>Fastify</strong>.</li><li><strong>Context</strong>: Express is unmaintained/slow. NestJS is too opinionated and heavy for the micro-service goal of this project. Fastify provides a high-performance base with a powerful plugin system that aligns with our modular architecture.</li></ul><h3 id="framework-performance" tabindex="-1">Framework Performance <a class="header-anchor" href="#framework-performance" aria-label="Permalink to “Framework Performance”">​</a></h3><table tabindex="0"><thead><tr><th style="text-align:left;">Framework</th><th style="text-align:center;">Requests/sec</th><th style="text-align:left;">Syntax</th></tr></thead><tbody><tr><td style="text-align:left;"><strong>Fastify</strong></td><td style="text-align:center;">~80k+</td><td style="text-align:left;">Functional/Plugin</td></tr><tr><td style="text-align:left;"><strong>Express</strong></td><td style="text-align:center;">~15k</td><td style="text-align:left;">Middleware</td></tr><tr><td style="text-align:left;"><strong>NestJS</strong></td><td style="text-align:center;">~30k</td><td style="text-align:left;">OOP/Decorators</td></tr></tbody></table><ul><li><strong>Consequences</strong>: <ul><li>✅ <strong>Pros</strong>: Highest performance in Node ecosystem, schema-based validation fits perfectly with Zod, great plugin ecosystem.</li><li>⚠️ <strong>Cons</strong>: Learning curve for hooks/plugins if coming from Express.</li></ul></li></ul><h2 id="adr-005-granular-error-handling" tabindex="-1">ADR-005: Granular Error Handling <a class="header-anchor" href="#adr-005-granular-error-handling" aria-label="Permalink to “ADR-005: Granular Error Handling”">​</a></h2><ul><li><strong>Status</strong>: Accepted</li><li><strong>Decision</strong>: Implement specific HTTP status codes (e.g., <strong>409 Conflict</strong>) instead of generic ones for resource state conflicts.</li><li><strong>Context</strong>: Relying on generic errors like 422 for everything makes it harder for API clients to handle specific business logic exceptions properly.</li><li><strong>Consequences</strong>: <ul><li>✅ <strong>Pros</strong>: Better client-side error handling, clearer API documentation, follows REST best practices.</li><li>⚠️ <strong>Cons</strong>: Slightly more verbose action logic to handle specific conflict scenarios.</li></ul></li></ul>',19)])])}const m=e(a,[["render",o]]);export{u as __pageData,m as default};
